<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Board.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OOPExcercises</a> &gt; <a href="index.source.html" class="el_package">default</a> &gt; <span class="el_source">Board.java</span></div><h1>Board.java</h1><pre class="source lang-java linenums">import java.util.HashSet;

public class Board {
<span class="fc" id="L4">    private int revealed = 0; //This represents the number of discovered safe tiles.</span>
    private int size;
<span class="fc" id="L6">    private boolean end = false;</span>
    private Tile[][] Tiles;
    private int minecount;
<span class="fc" id="L9">    private boolean firstClick = true;</span>
<span class="fc" id="L10">    public Board(int length) {</span>
<span class="fc" id="L11">        this.size = length;</span>
<span class="fc" id="L12">        this.Tiles = new Tile[size][size];</span>
<span class="fc bfc" id="L13" title="All 2 branches covered.">        for (int x=0 ; x&lt;length ; x++) {</span>
<span class="fc bfc" id="L14" title="All 2 branches covered.">            for (int y=0 ; y &lt; length ; y++) {</span>
<span class="fc" id="L15">                Tiles[x][y] = new Tile(x, y, this);</span>
            }
        }
<span class="fc" id="L18">    }</span>

    public void distributeMines(int count) { //Randomly places mines
<span class="fc" id="L21">        HashSet&lt;int[]&gt; pos = new HashSet&lt;&gt;();</span>
        do {
<span class="fc" id="L23">            int[] i = new int[2];</span>
<span class="fc" id="L24">            i[0] = (int) (Math.random()*(this.size));</span>
<span class="fc" id="L25">            i[1] = (int) (Math.random()*(this.size));</span>
            // Generates a set of coordinates within the bounds of the grid
            try { //Tries to add the coordinates to the hash set
<span class="fc" id="L28">                pos.add(i);</span>
<span class="fc" id="L29">                this.minecount++;</span>
<span class="nc" id="L30">            } catch (Exception ignored) {</span>
                //If the coordinates are a duplicate then the program will not add or crash as the exception is handled
<span class="fc" id="L32">            }</span>
<span class="fc bfc" id="L33" title="All 2 branches covered.">        } while (pos.size()&lt;count); // Continues generating coords and adding them if unique until the count quota has been met</span>
<span class="fc bfc" id="L34" title="All 2 branches covered.">        for (int[] m : pos) {</span>
<span class="fc" id="L35">            this.Tiles[m[0]][m[1]].setMine(true); //sets the Mine boolean of the tiles at all generated coordinates to true</span>
<span class="fc" id="L36">        }</span>
<span class="fc" id="L37">    }</span>


    public int checkNeighbors(Tile target) { //Used for calculating the number of mines adjacent to a Tile
<span class="fc" id="L41">        int mines = 0; //represents the number to be displayed on the tile</span>
<span class="fc" id="L42">        int[][] neighbors = target.getNeighbours();</span>
<span class="fc bfc" id="L43" title="All 2 branches covered.">        for (int[] neighbor : neighbors) {</span>
                try {
<span class="fc bfc" id="L45" title="All 2 branches covered.">                    if (checkForMine(neighbor[0],neighbor[1])) {</span>
<span class="fc" id="L46">                        mines++;</span>
                        //If a mine is present at the coordinate then increment mines
                    }
                }
<span class="fc" id="L50">                catch(Exception ignored) {</span>
                    /*
                    Edge tiles would ordinarily check outside the grid and cause an error.
                    This allows such cases to be skipped without issue
                     */
<span class="fc" id="L55">                }</span>
            }
<span class="fc" id="L57">        return mines;</span>
    }
    public boolean checkForMine(int x, int y) {
<span class="fc" id="L60">        return this.Tiles[x][y].getMine();</span>
        //Checks the Tile of a given coordinate for a mine.
    }

    public void revealTile(Tile target) { //Reveals a tile. Should that tile have no neighboring mines then all of those tiles are revealed too
<span class="fc" id="L65">        target.setRevealed(true);</span>
<span class="fc" id="L66">        revealed++;</span>
<span class="pc bpc" id="L67" title="3 of 4 branches missed.">        if (target.getMine() &amp;&amp; this.isFirstClick()) {</span>
<span class="nc" id="L68">            target.setMine(false);</span>
<span class="nc" id="L69">            this.firstClick = false;</span>
        }
<span class="fc" id="L71">        target.getButton().setText(String.valueOf(checkNeighbors(target)));</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">        if (checkNeighbors(target)==0) { //</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">            for (int[] n : target.getNeighbours()) {</span>
                try {
<span class="nc bnc" id="L75" title="All 2 branches missed.">                    if (!this.Tiles[n[0]][n[1]].getRevealed()) {</span>
<span class="nc" id="L76">                        revealTile(this.Tiles[n[0]][n[1]]);</span>
                        //0-Value Tiles are recursively checked until none remain contiguously
                    }

<span class="nc" id="L80">                } catch (Exception ignored) {</span>
                    /*
                    Edge tiles would ordinarily check outside the grid and cause an error.
                    This allows such cases to be skipped without issue
                     */
<span class="nc" id="L85">                }</span>
            }
        }
<span class="fc" id="L88">    }</span>
    public void flagTile(Tile target) { //swaps the flagged state of a given tile
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">        target.setFlagged(!target.getFlagged());</span>
<span class="fc" id="L91">    }</span>


    /*
    Getters and Setters
     */
    public int getSize() {
<span class="fc" id="L98">        return this.size;</span>
    }
    public Tile[][] getTiles() {
<span class="fc" id="L101">        return this.Tiles;</span>
    }
    public boolean getEnd() {
<span class="fc" id="L104">        return end;</span>
    }
    public void setEnd(boolean end) {
<span class="fc" id="L107">        this.end = end;</span>
<span class="fc" id="L108">    }</span>
    public int getMinecount() {
<span class="fc" id="L110">        return this.minecount;</span>
    }
    public int getRevealed() {
<span class="nc" id="L113">        return revealed;</span>
    }
    public void setRevealed(int revealed) {
<span class="nc" id="L116">        this.revealed = revealed;</span>
<span class="nc" id="L117">    }</span>
    public boolean isFirstClick() {
<span class="nc" id="L119">        return firstClick;</span>
    }
    public void setFirstClick(boolean firstClick) {
<span class="fc" id="L122">        this.firstClick = firstClick;</span>
<span class="fc" id="L123">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>